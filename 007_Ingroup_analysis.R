#############################################################################

# In group analysis Grevillea project   - Started 07/03/2024

#############################################################################
library(dartR)

gl.install.vanilla.dartR()
library(ape)
library(plotly)
library(StAMPP)
library(hierfstat)
library(directlabels)
library(pheatmap)
library(rrBLUP)
library(plotrix)
library(graph4lg)
library(gdata)
library(poppr)
library(RColorBrewer)
library(gplots)

sessionInfo()

gl <- gl.read.dart(filename="Report_DGr23-8087_SNP_2.csv",
                       ind.metafile="metadata_05032024_wo_clones.csv")

gl                                  # gives overview of the genlight object

# ind.metafile ids not matched were:
# [1] "OUT1-01" "OUT1-02" "OUT1-03" "OUT1-04" "OUT1-05" "OUT2-01" "OUT2-02"
# [8] "OUT2-03" "OUT2-04" "OUT3-03" "OUT3-04" "OUT3-05" "OUT4-01" "OUT4-02"
# [15] "OUT4-03" "OUT4-04"
# 
# DArT file ids not matched were: (CLONES)
#   [1] "AUS1-02" "AUS1-03" "BRO4-01" "BLA9-02" "YEL1-01" "BRO4-03" "TYP6-01"
# [8] "YEL1-02" "TYP6-02" "YEL1-03" "YEL1-04" "GRA4-05" "BLA9-05" "GRA2-06"
# [15] "YEL1-05" "BLA9-06" "TYP6-03" "YEL1-06" "TYP6-04" "YEL1-08"


# 146 genotypes,  175,577 SNPs , size: 164.6 Mb
# 
# missing data: 8533497 (=33.29 %) scored as NA

class(gl)<- "genlight"  
gl.report.rdepth(gl)

# No. of loci = 175577 
# No. of individuals = 146 
# Minimum      :  2.5 
# 1st quartile :  8 
# Median       :  16.2 
# Mean         :  21.41601 
# 3r quartile  :  29.8 
# Maximum      :  368.8 
# Missing Rate Overall:  0.33 

gl.smearplot(gl)

# FILTER 1: For POP GEN analysis, remove secondary (linked) snps to reduce dataset to single SNP per fragment

# This script filters out all but the first sequence tag with the same CloneID after ordering
# the genlight object on based on repeatability, avgPIC in that order (method='best') 
# or at random (method='random').

filter1 <- gl.filter.secondaries(gl, method="best", v=3)

# Number of secondaries: 65528 
# Number of loci after secondaries removed: 110049 


# look at histograms of QC metrics to see the spread of data: helps decide on next filtering thresholds
gl.report.rdepth(filter1)                   # read depth: the number of sequence tags per locus
# cutoff of 100
gl.report.reproducibility(filter1)          # reproducibility: the proportion of technical replicate assay pairs for which the marker score is consistent
#Known SNP calls between replicates, set at 0.99
gl.report.callrate(filter1)                 # call rate: the proportion of samples for which the genotype call is either "0" or "1", rather than "-" 
#0.80
gl.report.maf(filter1)                      # frequency of reference allele (aka minor allele frequency)
# Minor allele frequency (MAF) is the frequency at which the second most common allele occurs in a given population.
#Always set to 0.02

# FILTERS 2-6: locus filters on read depth, reproducibility, call rate, minor allele frequency and remove any monomorphic loci
filter2 <- gl.filter.rdepth(filter1, lower=5, upper=100, v=3)
filter3 <- gl.filter.reproducibility(filter2, t=0.99, v=3)
filter4 <- gl.filter.callrate(filter3, method="loc", threshold=0.80, v=3)
filter5 <- gl.filter.maf(filter4, threshold=0.02, verbose=3)
filter6 <- gl.filter.monomorphs(filter5, v=2)
filter6

# 146 genotypes,  13,201 binary SNPs, size: 76.2 Mb
# 213726 (11.09 %) missing data

# SNP datasets generated by DArT have missing values primarily arising from failure to 
# call a SNP because of a mutation at one or both of the restriction enzyme recognition sites.
# The script gl.filter.callrate() will filter out the loci with call rates below a specified
# threshold.

gl.report.callrate(filter6, method="ind")
filter7 <- gl.filter.callrate(filter6, method="ind", threshold=0.80)
filter7

# Individuals deleted (CallRate <=  0.8 ):
#   BLA3-03[BLA3], GRA2-02[GRA2], GRA4-03[GRA4], 
#   BLA4-01[BLA4], GRA2-03[GRA2], TYP3-02[TYP3], BLA5-01[BLA5],
#   AUS3-02[AUS3], TYP4-06[TYP4], BRO1-07[BRO1], BRO4-07[BRO4],
#   TYP3-05[TYP3], BLA2-04[BLA2], TYP1-04[TYP1], YEL1-07[YEL1], 
#   BLA7-06[BLA7],

# // 130 genotypes,  13,201 binary SNPs, size: 75.7 Mb
# 116319 (6.78 %) missing data

# 6.8% is still a bit high. Let's see if we can bring this down with another 
#round of filtering

gl.report.rdepth(filter7)                   # read depth: the number of sequence tags per locus
gl.report.reproducibility(filter7)          # reproducibility: the proportion of technical replicate assay pairs for which the marker score is consistent
gl.report.callrate(filter7)                 # call rate: the proportion of samples for which the genotype call is either "0" or "1", rather than "-" 
gl.report.maf(filter7) 

#The main thing is the call rate, I think we can increase that to .85
#Could also drop read depth to 90

filter2b <- gl.filter.rdepth(filter7, lower=5, upper=90, v=3)
filter4b <- gl.filter.callrate(filter2b, method="loc", threshold=0.85, v=3)
filter4b

# // 130 genotypes,  12,405 binary SNPs, size: 75.4 Mb
# 100530 (6.23 %) missing data

gl.report.callrate(filter4b, method="ind")
filter7b <- gl.filter.callrate(filter4b, method="ind", threshold=0.85)
filter7b

# 125 genotypes,  12,405 binary SNPs, size: 75.3 Mb
# 90097 (5.81 %) missing data

#Hmm, I think we have enough SNPs that we can be a bit more strict.Let's just
# fix call rate and indv. call rate

filter4c <- gl.filter.callrate(filter7b, method="loc", threshold=0.90, v=3)
filter7c <- gl.filter.callrate(filter4c, method="ind", threshold=0.90)


filter7c
# // 122 genotypes,  9,805 binary SNPs, size: 74.1 Mb
# 47006 (3.93 %) missing data

#I'm happy with that

data <- gl.recalc.metrics(filter7c)
gl.report.rdepth(data)
gl.smearplot(data)             
data

# save genlight object (.Rdata) and/or csv file of filtered genotypes and locus metadata if wanted
gl.save(data2, "Grevillea_9kloci.Rdata")


pcoa <- gl.pcoa(data, nfactors=5)

#2 axes looks good

gl.pcoa.plot(pcoa, data, pop.labels="pop", xaxis=1, yaxis=2, zaxis=NULL, interactive=TRUE)

# Let's create this as a neat plot
library(tidyr)
library(FactoMineR)

pop(data) <- data@other$ind.metrics$species

write.table(pcoa$scores, "Grevillea_pcoascores_9Kloci.txt", quote=FALSE, sep="\t")
write.table(pop(data), "Grevillea_species_9Kloci.txt", quote=FALSE, sep="\t")

pop(data) <- data@other$ind.metrics$pop

write.table(pop(data), "Grevillea_pops_9Kloci.txt", quote=FALSE, sep="\t")

pcoa_scores <- read.table("Grevillea_pcoascores_9Kloci.txt", header = TRUE, dec = ".")
species_data <- read.table("Grevillea_species_9Kloci.txt", header = TRUE)
pop_data <- read.table("Grevillea_pops_9Kloci.txt", header = TRUE)

df_IN <- cbind(pcoa_scores, species_data, pop_data)

write.table(df_IN, "Grevillea_9Kloci_IN.txt", quote=FALSE, sep="\t")
df <- read.table("Grevillea_9Kloci_IN.txt", header = TRUE)

View(df)
colnames(df)

# Rename columns

names(df)[names(df) == "x"] <- "species"
names(df)[names(df) == "x.1"] <- "pop"
colnames(df)


shapes <- c(15, 8, 16, 17, 18, 19, 7)

pca_plot <- ggplot(df, aes(x = PC1, y = PC2, color = pop, shape = species)) +
  geom_point(size = 3, alpha = 0.7) +
  theme_minimal() +
  labs(title = "PCA Plot", x = "PC1 (16%)", y = "PC2 (8.6%)") +
  scale_color_discrete(name = "Population") +
  geom_vline(xintercept = 0, linetype = "dashed") +
  geom_hline(yintercept = 0, linetype = "dashed") +
  scale_shape_manual(values = shapes) +
  theme(legend.position = "right")  + 
  theme(plot.title = element_blank())

# Print the plot
print(pca_plot)

png(filename = "Plots/pca_9k.png")
dev.off()

###### SNMF analysis ##################
if (!require("BiocManager", quietly = TRUE))
  install.packages("BiocManager")

BiocManager::install("LEA")

library(LEA)

strgl <- data
index <- 1
pops <- sort(unique(strgl$pop))
for (pop in pops) {
  levels(strgl$pop)[match(pop, levels(strgl$pop))] <- index
  index <- index + 1
}

gl2structure(strgl, outfile = "9k_Grevillea13032024.str", addcolumns = strgl$pop, exportMarkerNames = FALSE, outpath = ".")

#Edit in Textpad8

filename3 <- "9k_Grevillea_13032024.str"
filename3
struct2geno(filename3, ploidy = 2, FORMAT=2, extra.col=2)

geno <- "9k_Grevillea.str.geno"

# need to set upper limit of K values and number of repetitions (100-1000 depending on size of dataset)
# all other parameters can be left as they are
project <- snmf(input.file = geno,
                K = 1:10,
                ploidy = 2,
                repetitions = 100,
                entropy = TRUE,
                percentage = 0.2,
                project = "new")

# indicate max K value and plot the cross-entropy criterion as a function of K to see where it plateaus (= optimal K)
kmax <- 10
cross <- sapply(1:kmax, function(k) { LEA::cross.entropy(project, run = 1, K = k) })
kplot <- plot(1:kmax, cross, main = "Cross Entropy", type="b", xlab = "K", ylab = "cross entropy")

print(k_plot)
png(filename = "Plots/kplot_9k.png")

#looks like it is plateauing between 4 - 8 

# for chosen K value and run, choose # colours needed and plot barchart 
# can also export the Q values if prefer to plot in excel
library(viridis)
?viridis

kchoice=6
mycol=palette.colors(kchoice)
par(mfrow = c(7,1),  mai = c(0.2, 0.3, 0.1, 0.1))

kchoice=2
p2 <- barchart(project, K=kchoice, run=65, sort.by.Q = FALSE, lab = FALSE, col=mycol , border=TRUE, xaxt="n", ylab = "")

kchoice=3
p3 <- barchart(project, K=kchoice, run=65, sort.by.Q = FALSE, lab = FALSE, col=mycol, border=TRUE, xaxt="n", ylab = "")

kchoice=4
p4 <- barchart(project, K=kchoice, run=65, sort.by.Q = FALSE, lab = FALSE, col=mycol, border=TRUE, xaxt="n", ylab = "")

kchoice=5
p5 <- barchart(project, K=kchoice, run=65, sort.by.Q = FALSE, lab = FALSE, col=mycol, border=TRUE, xaxt="n", ylab = "")

kchoice=6
p6 <- barchart(project, K=kchoice, run=65, sort.by.Q = FALSE, lab = FALSE, col=mycol, border=TRUE, xaxt="n", ylab = "")

kchoice=7
p7 <- barchart(project, K=kchoice, run=65, sort.by.Q = FALSE, lab = FALSE, col=mycol, border=TRUE, xlab = "Individuals", ylab = "")

kchoice=8
p8 <- barchart(project, K=kchoice, run=65, sort.by.Q = FALSE, lab = FALSE, col=mycol, border=TRUE, xlab = "Individuals", ylab = "Admixture coefficients")


# save data for chosen k value/s
qvalues<-LEA::Q(project, K=kchoice, run=65)
write.table(qvalues, "Grevillea_9k_k_values.txt", quote=FALSE)


# Graphic now exported to Inkscape and populations added manually by counting the number of
# individuals for each pop and drawing a red line through all seven column graphs.

#####################################################################################

#                        DIVERSITY + F-sTATS for Grevillea 11/03/2024

######################################################################################

# OPTIONAL: if needing to change the pop labels to another ind metrics slot, e.g. lineage, species, sex etc. Just don't forget to change back!
pop(data) <- data@other$ind.metrics$pop
pop(data) <- data@other$ind.metrics$species

# estimates standard He, Ho and Fis and standard error per population (can also estimate per individual, method="ind")
# ignores estimates of adjusted Ho/He, see next section if want to estimate these parameters
het_stats_pop <- gl.report.heterozygosity(data, method="pop")
het_stats_loci <- utils.basic.stats(data)

# There are populations with one individual. Please remove populations with one individual or merged them with other populations for his function to work
# Error in colSums(apply(sgl_mat[[y]], 2, is.na)) : 
#   'x' must be an array of at least two dimensions

table(pop(data))  

# AUS1 AUS2 AUS3 BLA1 BLA2 BLA3 BLA4 BLA5 BLA6 BLA7 BLA8 BLA9 BRO1 BRO2 BRO3 BRO4 GRA1 GRA2 GRA3 GRA4 TYP1 
# 6    4    6    6    5    4    4    5    5    4    6    3    6    7    5    3    6    3    6    4    5 
# TYP2 TYP3 TYP4 TYP5 TYP6 
# 5    3    5    5    1 

#So, we have to remove Type6, which only has one individual for the population.

# will delete all individuals in all populations except those listed.
data_new <- gl.drop.pop(data, pop.list=c("BLA9", "BRO4","GRA2","TYP3","TYP6"))

table(pop(data_new))  

# AUS1 AUS2 AUS3 BLA1 BLA2 BLA3 BLA4 BLA5 BLA6 BLA7 BLA8 BRO1 BRO2 BRO3 GRA1 GRA3 GRA4 TYP1 TYP2 TYP4 TYP5 
# 6    4    6    6    5    4    4    5    5    4    6    6    7    5    6    6    4    5    5    5    5 

het_stats_pop <- gl.report.heterozygosity(data_new, method="pop")
het_stats_loci <- utils.basic.stats(data_new)

het_standard <- cbind(het_stats_pop[, c("pop", "nInd", "nLoc", "polyLoc", "Ho", "HoSD", "He", "HeSD", "FIS")])

poly <- sapply(het_standard$polyLoc, function(x)x/het_standard$nLoc*100)  # calculates percentage polymorphic loci
poly <- poly[1,]
het_standard["PCpoly"] <-poly

ho_se <- sapply(het_standard$HoSD, function(x)x/sqrt(het_standard$nLoc))  # calculates standard error for Ho
ho_se <- ho_se[1,]
het_standard["Ho.SE"] <- ho_se

he_se <- sapply(het_standard$HeSD, function(x)x/sqrt(het_standard$nLoc))  # calculates standard error for He
he_se <- he_se[1,]
het_standard["He.SE"] <- he_se

fis_se <- sapply(het_stats_loci$Fis, function(x)sd(x, na.rm=TRUE)/sqrt(length(x)))  # calculates standard error for Fis
het_standard["Fis.SE"] <- fis_se

data_genind <- gl2gi(data_new)                                                          # calculates allelic richness and standard error
richness <- allelic.richness(data_genind)
richness_mean <- colMeans(richness$Ar, na.rm=TRUE)
richness_se <- sapply(richness$Ar, function(x)sd(x, na.rm=TRUE)/sqrt(length(x)))
het_standard["rich"] <- richness_mean
het_standard["rich.SE"] <- richness_se

het_standard <- het_standard[, c("pop", "nInd", "nLoc", "polyLoc", "PCpoly", "rich", "rich.SE", "Ho", "Ho.SE", "He","He.SE", "FIS", "Fis.SE")]   #re-arrange columns in sensible order
write.csv(het_standard, "Grevillea_9k_dataset_diversity_13032024.csv")  

# estimate pairwise fst values
fst <- gl.fst.pop(data_new, nboots=1000, percent=0.95)
pairwise_fst <- as.matrix(fst$Fsts)
pairwise_fst
final_fst<- pairwise_fst

# custom re-ordering of pairwise fst matrix for table or heatmap
sym_fst <- as.matrix(as.dist(fst$Fsts))
View(sym_fst)

table(pop(data_new))


order <- c("AUS1","AUS2","AUS3",                               #Australis - South
           "BLA1","BLA3","BLA4", "BLA5","BLA7","BLA8",         #Australis - North
           "GRA1","GRA3","BLA2","TYP1",                        #Grandis
           "GRA4","BLA6", "TYP2","TYP4","TYP5",                #Brachystylis
           "BRO2", "BRO1","BRO3")                              #Bronweneae

final_fst <- reorder_mat(mat=sym_fst, order=order)
final_fst

# export fst values to csv file
write.csv(final_fst, "Grevillea_pop_fst_Final_13032024.csv")

# basic heatmap of fst values
npop <- nPop(data_new)
mycol <- brewer.pal(n=9, name="Reds")
heatmap_def <- heatmap.2(final_fst, notecol="black", density.info="none", trace="none", Rowv=NA, Colv=NA, dendrogram=c("none"), col=mycol, colsep=c(0:npop), rowsep=c(0:npop), sepcolor="black", sepwidth=c(0.02, 0.02))

# calculate global fst/fis values (overall values at bottom of table)
gl.basic.stats(data_new)

# overall
# Ho     Hs     Ht    Dst    Htp   Dstp    Fst   Fstp    Fis   Dest 
# 0.0437 0.0640 0.1414 0.0773 0.1453 0.0812 0.5470 0.5591 0.3174 0.0868 

#Haven't done below test

# run mantel test on fst/1-fst vs log geog dist (requires lat + lon for each sample in the ind metrics file)
ibd <- gl.ibd(data)  
sink("CUNE_subset1_2621loci_ibd.txt")
print(ibd)
sink()



#Script below works

#####New analysis bits-------------------------------------------------------------------

# estimates adjusted He, Ho ("autosomal heterozygosity") and standard error per population
# requires a dataset with all secondary loci included so need a different dataset for this calculation!
# also requires input of the number of invariant sites from gl.report.secondaries


gl <- gl.read.dart(filename="Report_DGr23-8087_SNP_2.csv",
                   ind.metafile="metadata_05032024_wo_clones.csv")

class(gl)<- "genlight"  
gl.report.rdepth(gl)

#### Original Report

# No. of loci = 175577 
# No. of individuals = 146 
# Minimum      :  2.5 
# 1st quartile :  8 
# Median       :  16.2 
# Mean         :  21.41601 
# 3r quartile  :  29.8 
# Maximum      :  368.8 
# Missing Rate Overall:  0.33 

gl.report.rdepth(gl) # Yep, they match

# FILTERS 2-6: locus filters on read depth, reproducibility, call rate, minor allele frequency and remove any monomorphic loci
filter2 <- gl.filter.rdepth(gl, lower=5, upper=100, v=3)
filter3 <- gl.filter.reproducibility(filter2, t=0.99, v=3)
filter4 <- gl.filter.callrate(filter3, method="loc", threshold=0.80, v=3)
filter5 <- gl.filter.maf(filter4, threshold=0.02, verbose=3)
filter6 <- gl.filter.monomorphs(filter5, v=2)
filter6

# 146 genotypes,  13,201 binary SNPs, size: 76.2 Mb
# 213726 (11.09 %) missing data

gl.report.callrate(filter6, method="ind")
filter7 <- gl.filter.callrate(filter6, method="ind", threshold=0.80)
filter7

# // 130 genotypes,  23,021 binary SNPs, size: 79.6 Mb
# 221020 (7.39 %) missing data

filter2b <- gl.filter.rdepth(filter7, lower=5, upper=90, v=3)
filter4b <- gl.filter.callrate(filter2b, method="loc", threshold=0.85, v=3)
filter4b

# 130 genotypes,  21,448 binary SNPs, size: 78.9 Mb
# 189414 (6.79 %) missing data

gl.report.callrate(filter4b, method="ind")
filter7b <- gl.filter.callrate(filter4b, method="ind", threshold=0.85)
filter7b

# 125 genotypes,  21,448 binary SNPs, size: 78.8 Mb
# 171176 (6.38 %) missing data

filter4c <- gl.filter.callrate(filter7b, method="loc", threshold=0.90, v=3)
filter7c <- gl.filter.callrate(filter4c, method="ind", threshold=0.90)


filter7c
# 122 genotypes,  16,218 binary SNPs, size: 76.6 Mb
# 85580 (4.33 %) missing data

bob <- gl.recalc.metrics(filter7c)

table(pop(bob))

#remove populations with less than four individuals

bob2 <- gl.drop.pop(bob, pop.list=c("BLA9", "BRO4","GRA2","TYP3","TYP6"))

table(pop(bob2))

gl.report.secondaries(bob2)

?gl.report.heterozygosity

het_stats_adj <- gl.report.heterozygosity(bob2, method="pop", n.invariant=3509835)
het_adjusted <- cbind(het_stats_adj[, c(1, 2, 3, 10, 11, 16, 17)])

ho_adj_se <- sapply(het_adjusted$Ho.adjSD, function(x)x/sqrt(het_adjusted$nLoc))
ho_adj_se <- ho_adj_se[1,]
het_adjusted["Ho.adj.se"] <- ho_adj_se

he_adj_se <- sapply(het_adjusted$He.adjSD, function(x)x/sqrt(het_adjusted$nLoc))
he_adj_se <- he_adj_se[1,]
het_adjusted["He.adj.se"] <- he_adj_se

names(het_adjusted)
# [1] "pop"       "nInd"      "nLoc"      "Ho.adj"    "Ho.adjSD"  "He.adj"    "He.adjSD"  "Ho.adj.se"
# [9] "He.adj.se"

write.csv(het_adjusted, "grevillea_9K_subset_heterozygosity_adj_13032024.csv")

#Haven't exported to genalex

# output data as genalex input file to run AMOVA/IBD/SPATIALAUTOCORRELATION if wanted (I prefer genalex to dartR for these)
gl2genalex(data, outfile="GNX_TETRA_13k.csv", outpath=getwd())

#-----------------------------------------------------------------------------------------
#Map to interpret

gl.map.interactive(bob, ind.circle.cols="black")


##12/03/2024

# next, we need to work out what samples belong in what lineage to inform the Fst heatmap.
# To do this, I am going to use another program called Splitstree. The following code is
# to export the SNP data into a compatible format that plays nicely with this software.

# export distance matrix for SPLITSTREE input
# generates fasta file, converts to DNAbin object, calculates distance metric and exports in the correct format for splitstree
library(pofadinr)

install.packages("devtools")

#And then, install the pofadinr package from the github repository.

library(devtools)

install_github("simjoly/pofadinr")

#^ Doesn't work

isfar <- get(load('c:/Desktop/Stump/004_Data/001_SNP_Geno_G_brachystylis/Grevillea_9kloci.Rdata'))
class(a)<- "genlight"  
gl.report.rdepth(a)

#Error in readChar(con, 5L, useBytes = TRUE) : cannot open the connection
# In addition: Warning message:
#   In readChar(con, 5L, useBytes = TRUE) :
#   cannot open compressed file 'c:/Desktop/Stump/004_Data/001_SNP_Geno_G_brachystylis/Grevillea_9kloci.Rdata', 
#   probable reason 'No such file or directory'

#Go back to the top and recreate the data file with 9k snps

#done, now


data_fasta <- gl2fasta(data2, method=3, outfile="Grev_9k.fas", outpath=getwd())
filename = "Grev_9k.fas"

install_github("simjoly/pofadinr")

data_dnabin <- fasta2DNAbin(filename)

library(pofadinr)

genpofad_dist <- dist.snp(data_dnabin, model = "GENPOFAD", pairwise.deletion = TRUE, as.matrix=TRUE)  # can also use model="MATCHSTATES"
outfile <- file("Grev_9k.txt", open = "w")
writeLines(as.character(nInd(data2)), con = outfile)
write.table(genpofad_dist, file = outfile, sep = " ", append=TRUE, col.names=FALSE, quote=FALSE)

close(outfile)

############################################################################

# Bubble plot script - a new way to display He and Ho

###########################################################################

library(ggplot2)
library(dplyr)

#Snp data

View(het_standard)
head(het_standard)
het_standard %>%
  arrange(desc(Ho)) %>%
  mutate(pop = factor(pop, pop)) %>%
  ggplot(aes(x=He, y= Ho, size=FIS, color=pop)) +
  geom_point(alpha=0.5) +
  theme_classic() +
  scale_size(range = c(.1, 24), name="FIS")


#autsomal data

names(het_adjusted)

# [1] "pop"       "nInd"      "nLoc"      "Ho.adj"    "Ho.adjSD" 
# [6] "He.adj"    "He.adjSD"  "Ho.adj.se" "He.adj.se"

b <- het_adjusted %>%
  arrange(desc(Ho.adj)) %>%
  mutate(pop = factor(pop, pop)) %>%
  ggplot(aes(x=He.adj, y= Ho.adj, size=Ho.adj, color=pop)) +
  geom_point(alpha=0.5) +
  theme_classic() +
  scale_size(range = c(.1, 24), name="Observed Heterozygosity (Ho)")
  

library(ggpubr)

ggarrange(a,b, ncol = 2, nrow = 1, common.legend = TRUE)

###############################################################################

## Pie map from structure output

###############################################################################
a <- bob2@other$ind.metrics$id
b <- bob2@other$ind.metrics$lat
c <- bob2@other$ind.metrics$lon

d <- cbind(a,b,c)
View(d)

write.csv(d, "STR_LAT_LON.csv")

#Input files: pie plot details with coordinates; format including three parts:
# 1. individuals; 2. longitude and latitudes; 3. pie proportions

# e.g. 

#INDI LON  LAT   P1     P2       P3
# 1   4.2  50   0.02  0.004     0.97


library(reshape)
library(rworldmap)
library(rworldxtra)
library(mapdata)
library(sf)
?mapPies

K3 <- read.csv("010_Pie_in_the_sky.csv", sep = ",", header = T)
?mapPies

K3 <- as.data.frame(K3)

?getMap


lon_min <- 115
lon_max <- 118
lat_min <- -31
lat_max <- -31

map <- fortify(map("worldHires", 
                         xlim = c(lon_min, lon_max), 
                         ylim = c(lat_min, lat_max), 
                         fill = T, plot = F))

?mapPies
mapPies(dF = K3, nameX="LON", nameY= "LAT", nameZs=c("V1","V2", "V3", "V4", "V5"),
        zColours=c("steelblue2", "grey0", "palegreen4", "yellow3", "orange3"),
        oceanCol = "lightblue", landCol = "lightgrey", mapRegion = "world", 
        xlim = c(110, 130), ylim = c(-20, 0))



